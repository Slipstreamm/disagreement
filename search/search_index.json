{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Disagreement","text":"<p>This is the official documentation for the Disagreement library.</p> <p>To get started, check out the User Guide. See HybridContext and Rate Limiter for additional features or browse the API Reference.</p>"},{"location":"audit_logs/","title":"Audit Logs","text":"<p><code>Client.fetch_audit_logs</code> provides an async iterator over a guild's audit log entries.</p> <pre><code>async for entry in client.fetch_audit_logs(guild_id, limit=100):\n    print(entry.action_type, entry.user_id)\n</code></pre> <p>Discord imposes stricter rate limits on this endpoint compared to other REST calls. Avoid polling too frequently or you may hit a <code>429</code> response.</p>"},{"location":"audit_logs/#next-steps","title":"Next Steps","text":"<ul> <li>Caching</li> <li>Message History</li> </ul>"},{"location":"caching/","title":"Caching","text":"<p>Disagreement ships with a simple in-memory cache used by the HTTP and Gateway clients. Cached objects reduce API requests and improve performance.</p> <p>The client automatically caches guilds, channels and users as they are received from events or HTTP calls. You can access cached data through lookup helpers such as <code>Client.get_guild</code>.</p> <p>Once you have a <code>Guild</code> object you can look up its cached members. <code>Guild.get_member</code> retrieves a member by ID, while <code>Guild.get_member_named</code> searches by username or nickname:</p> <pre><code>guild = client.get_guild(123456789012345678)\nmember = guild.get_member_named(\"Slipstream\")\nif member:\n    print(member.display_name)\n</code></pre> <p>The cache can be cleared manually if needed:</p> <pre><code>client.cache.clear()\n</code></pre>"},{"location":"caching/#next-steps","title":"Next Steps","text":"<ul> <li>Components</li> <li>Slash Commands</li> <li>Voice Features</li> <li>HTTP Client Options</li> </ul>"},{"location":"commands/","title":"Commands Extension","text":"<p>This guide covers the built-in prefix command system.</p>"},{"location":"commands/#help-command","title":"Help Command","text":"<p>The command handler registers a <code>help</code> command automatically. Use it to list all available commands or get information about a single command.</p> <pre><code>!help              # lists commands\n!help ping         # shows help for the \"ping\" command\n</code></pre> <p>The help command will show each command's brief description if provided.</p>"},{"location":"commands/#checks","title":"Checks","text":"<p>Use <code>commands.check</code> to prevent a command from running unless a predicate returns <code>True</code>. Checks may be regular or async callables that accept a <code>CommandContext</code>.</p> <pre><code>from disagreement import command, check, CheckFailure\n\ndef is_owner(ctx):\n    return ctx.author.id == \"1\"\n\n@command()\n@check(is_owner)\nasync def secret(ctx):\n    await ctx.send(\"Only for the owner!\")\n</code></pre> <p>When a check fails a :class:<code>CheckFailure</code> is raised and dispatched through the command error handler.</p>"},{"location":"commands/#cooldowns","title":"Cooldowns","text":"<p>Commands can be rate limited using the <code>cooldown</code> decorator. The example below restricts usage to once every three seconds per user:</p> <pre><code>from disagreement import command, cooldown\n\n@command()\n@cooldown(1, 3.0)\nasync def ping(ctx):\n    await ctx.send(\"Pong!\")\n</code></pre> <p>Invoking a command while it is on cooldown raises :class:<code>CommandOnCooldown</code>.</p>"},{"location":"commands/#permission-checks","title":"Permission Checks","text":"<p>Use <code>commands.requires_permissions</code> to ensure the invoking member has the required permissions in the channel.</p> <pre><code>from disagreement import command, requires_permissions\nfrom disagreement import Permissions\n\n@command()\n@requires_permissions(Permissions.MANAGE_MESSAGES)\nasync def purge(ctx):\n    await ctx.send(\"Purged!\")\n</code></pre> <p>Missing permissions raise :class:<code>CheckFailure</code>.</p>"},{"location":"context_menus/","title":"Context Menu Commands","text":"<p><code>disagreement</code> supports Discord's user and message context menu commands. Use the <code>user_command</code> and <code>message_command</code> decorators to define them.</p> <pre><code>from disagreement import User, Message\nfrom disagreement import User, Message, user_command, message_command, AppCommandContext\n\n@user_command(name=\"User Info\")\nasync def user_info(ctx: AppCommandContext, user: User) -&gt; None:\n    await ctx.send(f\"User: {user.username}#{user.discriminator}\")\n\n@message_command(name=\"Quote\")\nasync def quote(ctx: AppCommandContext, message: Message) -&gt; None:\n    await ctx.send(message.content)\n</code></pre> <p>Add the commands to your client's handler and run <code>sync_commands()</code> to register them with Discord.</p>"},{"location":"converters/","title":"Command Argument Converters","text":"<p><code>disagreement.ext.commands</code> provides a number of built in converters that will parse string arguments into richer objects. These converters are automatically used when a command callback annotates its parameters with one of the supported types.</p>"},{"location":"converters/#supported-types","title":"Supported Types","text":"<ul> <li><code>int</code>, <code>float</code>, <code>bool</code>, and <code>str</code></li> <li><code>Member</code> \u2013 resolves a user mention or ID to a <code>Member</code> object for the current guild</li> <li><code>Role</code> \u2013 resolves a role mention or ID to a <code>Role</code> object</li> <li><code>Guild</code> \u2013 resolves a guild ID to a <code>Guild</code> object</li> </ul>"},{"location":"converters/#example","title":"Example","text":"<pre><code>from disagreement.ext.commands import command\nfrom disagreement import Member\nfrom disagreement.ext.commands.core import CommandContext\n\n@command()\nasync def kick(ctx: CommandContext, target: Member):\n    await target.kick()\n    await ctx.send(f\"Kicked {target.display_name}\")\n</code></pre> <p><code>Member.display_name</code> returns the member's nickname if one is set, otherwise it falls back to the username.</p> <p>The framework will automatically convert the first argument to a <code>Member</code> using the mention or ID provided by the user.</p>"},{"location":"embeds/","title":"Embeds","text":"<p><code>Embed</code> objects can be constructed piece by piece much like in <code>discord.py</code>. These helper methods return the embed instance so you can chain calls.</p> <pre><code>from disagreement import Embed\n\nembed = (\n    Embed()\n    .set_author(name=\"Disagreement\", url=\"https://example.com\", icon_url=\"https://cdn.example.com/bot.png\")\n    .add_field(name=\"Info\", value=\"Some details\")\n    .set_footer(text=\"Made with Disagreement\")\n    .set_image(url=\"https://cdn.example.com/image.png\")\n)\n</code></pre> <p>Call <code>to_dict()</code> to convert the embed back to a payload dictionary before sending:</p> <pre><code>payload = embed.to_dict()\n</code></pre>"},{"location":"events/","title":"Events","text":"<p>Disagreement dispatches Gateway events to asynchronous callbacks. Handlers can be registered with <code>@client.event</code>, <code>client.on_event</code>, or <code>client.add_listener(event_name, coro)</code>. Listeners may be removed later using <code>client.remove_listener(event_name, coro)</code> or <code>EventDispatcher.unregister(event_name, coro)</code>.</p>"},{"location":"events/#raw-events","title":"Raw Events","text":"<p>Every Gateway event is also emitted with a <code>RAW_</code> prefix containing the unparsed payload. Raw events fire before any caching or parsing occurs.</p> <pre><code>@client.on_event(\"RAW_MESSAGE_DELETE\")\nasync def handle_raw_delete(payload: dict):\n    print(\"message deleted\", payload[\"id\"])\n</code></pre>"},{"location":"events/#presence_update","title":"PRESENCE_UPDATE","text":"<p>Triggered when a user's presence changes. The callback receives a <code>PresenceUpdate</code> model.</p> <pre><code>@client.event\nasync def on_presence_update(presence: PresenceUpdate):\n    ...\n</code></pre>"},{"location":"events/#typing_start","title":"TYPING_START","text":"<p>Dispatched when a user begins typing in a channel. The callback receives a <code>TypingStart</code> model.</p> <pre><code>@client.event\nasync def on_typing_start(typing: TypingStart):\n    ...\n</code></pre>"},{"location":"events/#guild_member_add","title":"GUILD_MEMBER_ADD","text":"<p>Fired when a new member joins a guild. The callback receives a <code>Member</code> model.</p> <pre><code>@client.event\nasync def on_guild_member_add(member: Member):\n    ...\n</code></pre>"},{"location":"events/#guild_member_remove","title":"GUILD_MEMBER_REMOVE","text":"<p>Triggered when a member leaves or is removed from a guild. The callback receives a <code>GuildMemberRemove</code> model.</p> <pre><code>@client.event\nasync def on_guild_member_remove(event: GuildMemberRemove):\n    ...\n</code></pre>"},{"location":"events/#guild_ban_add","title":"GUILD_BAN_ADD","text":"<p>Dispatched when a user is banned from a guild. The callback receives a <code>GuildBanAdd</code> model.</p> <pre><code>@client.event\nasync def on_guild_ban_add(event: GuildBanAdd):\n    ...\n</code></pre>"},{"location":"events/#guild_ban_remove","title":"GUILD_BAN_REMOVE","text":"<p>Dispatched when a user's ban is lifted. The callback receives a <code>GuildBanRemove</code> model.</p> <pre><code>@client.event\nasync def on_guild_ban_remove(event: GuildBanRemove):\n    ...\n</code></pre>"},{"location":"events/#channel_update","title":"CHANNEL_UPDATE","text":"<p>Sent when a channel's settings change. The callback receives an updated <code>Channel</code> model.</p> <pre><code>@client.event\nasync def on_channel_update(channel: Channel):\n    ...\n</code></pre>"},{"location":"events/#guild_role_update","title":"GUILD_ROLE_UPDATE","text":"<p>Emitted when a guild role is updated. The callback receives a <code>GuildRoleUpdate</code> model.</p> <pre><code>@client.event\nasync def on_guild_role_update(event: GuildRoleUpdate):\n    ...\n</code></pre>"},{"location":"events/#shard_connect","title":"SHARD_CONNECT","text":"<p>Fired when a shard establishes its gateway connection. The callback receives a dictionary with the shard ID.</p> <pre><code>@client.event\nasync def on_shard_connect(info: dict):\n    print(\"shard connected\", info[\"shard_id\"])\n</code></pre>"},{"location":"events/#shard_disconnect","title":"SHARD_DISCONNECT","text":"<p>Emitted when a shard's gateway connection is closed. The callback receives a dictionary with the shard ID.</p> <pre><code>@client.event\nasync def on_shard_disconnect(info: dict):\n    ...\n</code></pre>"},{"location":"events/#shard_resume","title":"SHARD_RESUME","text":"<p>Sent when a shard successfully resumes after a reconnect. The callback receives a dictionary with the shard ID.</p> <pre><code>@client.event\nasync def on_shard_resume(info: dict):\n    ...\n</code></pre>"},{"location":"events/#connect","title":"CONNECT","text":"<p>Dispatched when the WebSocket connection opens. The callback receives a dictionary with the shard ID.</p> <pre><code>@client.event\nasync def on_connect(info: dict):\n    print(\"connected\", info.get(\"shard_id\"))\n</code></pre>"},{"location":"events/#disconnect","title":"DISCONNECT","text":"<p>Fired when the WebSocket connection closes. The callback receives a dictionary with the shard ID.</p> <pre><code>@client.event\nasync def on_disconnect(info: dict):\n    ...\n</code></pre>"},{"location":"events/#voice_state_update","title":"VOICE_STATE_UPDATE","text":"<p>Triggered when a user's voice connection state changes, such as joining or leaving a voice channel. The callback receives a <code>VoiceStateUpdate</code> model.</p> <pre><code>@client.event\nasync def on_voice_state_update(state: VoiceStateUpdate):\n    ...\n</code></pre>"},{"location":"extension_loader/","title":"Extension Loader","text":"<p>The <code>disagreement.ext.loader</code> module provides simple helpers to manage optional extensions. Extensions are regular Python modules that expose a <code>setup</code> function called when the extension is loaded.</p> <pre><code>from disagreement.ext import loader\n</code></pre> <ul> <li><code>loader.load_extension(name)</code> \u2013 Import and initialize an extension.</li> <li><code>loader.unload_extension(name)</code> \u2013 Tear down and remove a previously loaded   extension.</li> <li><code>loader.reload_extension(name)</code> \u2013 Convenience wrapper that unloads then loads   the extension again.</li> </ul>"},{"location":"gateway/","title":"Gateway Connection and Reconnection","text":"<p><code>GatewayClient</code> manages the library's WebSocket connection. When the connection drops unexpectedly, it will now automatically attempt to reconnect using an exponential backoff strategy with jitter.</p> <p>The default behaviour tries up to five reconnect attempts, doubling the delay each time up to a configurable maximum. A small random jitter is added to spread out reconnect attempts when multiple clients restart at once.</p> <p>You can control the maximum number of retries and the backoff cap when constructing <code>Client</code>. These options are forwarded to <code>GatewayClient</code> as <code>max_retries</code> and <code>max_backoff</code>:</p> <pre><code>from disagreement import Client\n\nbot = Client(\n    token=\"your-token\",\n    gateway_max_retries=10,\n    gateway_max_backoff=120.0,\n)\n</code></pre> <p>These values are passed to <code>GatewayClient</code> and applied whenever the connection needs to be re-established.</p>"},{"location":"gateway/#gateway-intents","title":"Gateway Intents","text":"<p><code>GatewayIntent</code> values control which events your bot receives from the Gateway. Use <code>GatewayIntent.none()</code> to opt out of all events entirely. It returns <code>0</code>, which represents a bitmask with no intents enabled.</p>"},{"location":"http_client/","title":"HTTP Client Options","text":"<p>Disagreement uses <code>aiohttp</code> for all HTTP requests. Additional options for the underlying <code>aiohttp.ClientSession</code> can be provided when constructing a <code>Client</code> or an <code>HTTPClient</code> directly.</p> <pre><code>import aiohttp\nfrom disagreement import Client\n\nconnector = aiohttp.TCPConnector(limit=50)\nclient = Client(\n    token=\"YOUR_TOKEN\",\n    http_options={\"proxy\": \"http://localhost:8080\", \"connector\": connector},\n)\n</code></pre> <p>These options are passed through to <code>aiohttp.ClientSession</code> when the session is created. You can set a proxy URL, provide a custom connector, or supply any other supported session argument.</p>"},{"location":"http_client/#get-current-user-guilds","title":"Get Current User Guilds","text":"<p>The HTTP client can list the guilds the bot user is in:</p> <pre><code>from disagreement import HTTPClient\n\nhttp = HTTPClient(token=\"TOKEN\")\nguilds = await http.get_current_user_guilds()\n</code></pre>"},{"location":"hybrid_context/","title":"HybridContext","text":"<p><code>HybridContext</code> wraps either a prefix <code>CommandContext</code> or a slash <code>AppCommandContext</code>. It exposes a single <code>send</code> method that proxies to the appropriate reply method for the underlying context.</p> <pre><code>from disagreement import HybridContext\n\n@commands.command()\nasync def ping(ctx: commands.CommandContext) -&gt; None:\n    hybrid = HybridContext(ctx)\n    await hybrid.send(\"Pong!\")\n</code></pre> <p>It also forwards attribute access to the wrapped context and provides an <code>edit</code> helper when supported.</p>"},{"location":"i18n/","title":"Internationalization","text":"<p>Disagreement can translate command names, descriptions and other text using JSON translation files.</p>"},{"location":"i18n/#providing-translations","title":"Providing Translations","text":"<p>Use <code>disagreement.i18n.load_translations</code> to load a JSON file for a locale.</p> <pre><code>from disagreement import i18n\n\ni18n.load_translations(\"es\", \"path/to/es.json\")\n</code></pre> <p>The JSON file should map translation keys to translated strings:</p> <pre><code>{\n  \"greet\": \"Hola\",\n  \"description\": \"Comando de saludo\"\n}\n</code></pre> <p>You can also set translations programmatically with <code>i18n.set_translations</code>.</p>"},{"location":"i18n/#using-with-commands","title":"Using with Commands","text":"<p>Pass a <code>locale</code> argument when defining an <code>AppCommand</code> or using the decorators. The command name and description will be looked up using the loaded translations.</p> <pre><code>@slash_command(name=\"greet\", description=\"description\", locale=\"es\")\nasync def greet(ctx):\n    await ctx.send(i18n.translate(\"greet\", ctx.locale or \"es\"))\n</code></pre> <p>If a translation is missing the key itself is returned.</p>"},{"location":"introduction/","title":"Disagreement","text":"<p>A Python library for interacting with the Discord API, with a focus on bot development.</p>"},{"location":"introduction/#features","title":"Features","text":"<ul> <li>Asynchronous design using <code>aiohttp</code></li> <li>Gateway and HTTP API clients</li> <li>Slash command framework</li> <li>Message component helpers</li> <li>Internationalization helpers</li> <li>Hybrid context for commands</li> <li>Built-in rate limiting</li> <li>Built-in caching layer</li> <li>Experimental voice support</li> <li>Helpful error handling utilities</li> </ul>"},{"location":"introduction/#installation","title":"Installation","text":"<pre><code>python -m pip install -U pip\npip install disagreement\n# or install from source for development\npip install -e .\n</code></pre> <p>Requires Python 3.10 or newer.</p> <p>To run the example scripts, you'll need the <code>python-dotenv</code> package to load environment variables. Install the development extras with:</p> <pre><code>pip install \"disagreement[dev]\"\n</code></pre>"},{"location":"introduction/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nimport os\n\nfrom disagreement import Client, GatewayIntent\nfrom disagreement.ext import commands\nfrom dotenv import load_dotenv\nload_dotenv()\n\n\nclass Basics(commands.Cog):\n    def __init__(self, client: Client) -&gt; None:\n        super().__init__(client)\n\n    @commands.command()\n    async def ping(self, ctx: commands.CommandContext) -&gt; None:\n        await ctx.reply(f\"Pong! Gateway Latency: {self.client.latency_ms} ms.\")\n\n\ntoken = os.getenv(\"DISCORD_BOT_TOKEN\")\nif not token:\n    raise RuntimeError(\"DISCORD_BOT_TOKEN environment variable not set\")\n\nintents = GatewayIntent.default() | GatewayIntent.MESSAGE_CONTENT\nclient = Client(token=token, command_prefix=\"!\", intents=intents, mention_replies=True)\nasync def main() -&gt; None:\n    client.add_cog(Basics(client))\n    await client.run()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"introduction/#global-error-handling","title":"Global Error Handling","text":"<p>To ensure unexpected errors don't crash your bot, you can enable the library's global error handler:</p> <pre><code>import disagreement\n\ndisagreement.setup_global_error_handler()\n</code></pre> <p>Call this early in your program to log unhandled exceptions instead of letting them terminate the process.</p>"},{"location":"introduction/#configuring-logging","title":"Configuring Logging","text":"<p>Use :func:<code>disagreement.logging_config.setup_logging</code> to configure logging for your bot. The helper accepts a logging level and an optional file path.</p> <pre><code>import logging\nfrom disagreement.logging_config import setup_logging\n\nsetup_logging(logging.INFO)\n# Or log to a file\nsetup_logging(logging.DEBUG, file=\"bot.log\")\n</code></pre>"},{"location":"introduction/#http-session-options","title":"HTTP Session Options","text":"<p>Pass additional keyword arguments to <code>aiohttp.ClientSession</code> using the <code>http_options</code> parameter when constructing :class:<code>Client</code>:</p> <pre><code>client = Client(\n    token=token,\n    http_options={\"proxy\": \"http://localhost:8080\"},\n)\n</code></pre> <p>These options are forwarded to <code>HTTPClient</code> when it creates the underlying <code>aiohttp.ClientSession</code>. You can specify a custom <code>connector</code> or any other session parameter supported by <code>aiohttp</code>.</p>"},{"location":"introduction/#default-allowed-mentions","title":"Default Allowed Mentions","text":"<p>Specify default mention behaviour for all outgoing messages when constructing the client:</p> <pre><code>from disagreement.models import AllowedMentions\nclient = Client(\n    token=token,\n    allowed_mentions=AllowedMentions.none().to_dict(),\n)\n</code></pre> <p>This dictionary is used whenever <code>send_message</code> or helpers like <code>Message.reply</code> are called without an explicit <code>allowed_mentions</code> argument.</p> <p>The :class:<code>AllowedMentions</code> class offers <code>none()</code> and <code>all()</code> helpers for quickly generating these configurations.</p>"},{"location":"introduction/#defining-subcommands-with-appcommandgroup","title":"Defining Subcommands with <code>AppCommandGroup</code>","text":"<pre><code>from disagreement.ext.app_commands import AppCommandGroup, slash_command\nfrom disagreement.ext.app_commands.context import AppCommandContext\n\nsettings_group = AppCommandGroup(\"settings\", \"Manage settings\")\nadmin_group = AppCommandGroup(\"admin\", \"Admin settings\", parent=settings_group)\n\n\n@slash_command(name=\"show\", description=\"Display a setting.\", parent=settings_group)\nasync def show(ctx: AppCommandContext, key: str):\n    ...\n\n\n@slash_command(name=\"set\", description=\"Update a setting.\", parent=admin_group)\nasync def set_setting(ctx: AppCommandContext, key: str, value: str):\n    ...\n</code></pre>"},{"location":"introduction/#fetching-guilds","title":"Fetching Guilds","text":"<p>Use <code>Client.fetch_guild</code> to retrieve a guild from the Discord API if it isn't already cached. This is useful when working with guild IDs from outside the gateway events.</p> <pre><code>guild = await client.fetch_guild(\"123456789012345678\")\nroles = await client.fetch_roles(guild.id)\n</code></pre> <p>To retrieve all guilds available to the bot, use <code>Client.fetch_guilds</code>.</p> <pre><code>guilds = await client.fetch_guilds()\n</code></pre>"},{"location":"introduction/#sharding","title":"Sharding","text":"<p>To run your bot across multiple gateway shards, pass <code>shard_count</code> when creating the client:</p> <pre><code>client = Client(token=BOT_TOKEN, shard_count=2)\n</code></pre> <p>If you want the library to determine the recommended shard count automatically, use <code>AutoShardedClient</code>:</p> <pre><code>from disagreement import AutoShardedClient\nclient = AutoShardedClient(token=BOT_TOKEN)\n</code></pre> <p>See <code>examples/sharded_bot.py</code> for a full example.</p>"},{"location":"introduction/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please open an issue or submit a pull request.</p> <p>See the documentation home for detailed guides on components, slash commands, caching, and voice features.</p>"},{"location":"introduction/#license","title":"License","text":"<p>This project is licensed under the BSD 3-Clause license. See the LICENSE file for details.</p>"},{"location":"invites/","title":"Working with Invites","text":"<p>The library exposes helper methods for creating and deleting invites.</p>"},{"location":"invites/#create-an-invite","title":"Create an Invite","text":"<pre><code>invite = await client.create_invite(\"1234567890\", {\"max_age\": 3600})\nprint(invite.code)\n</code></pre>"},{"location":"invites/#delete-an-invite","title":"Delete an Invite","text":"<pre><code>await client.delete_invite(invite.code)\n</code></pre>"},{"location":"invites/#list-invites","title":"List Invites","text":"<pre><code>invites = await client.fetch_invites(\"1234567890\")\nfor inv in invites:\n    print(inv.code, inv.uses)\n</code></pre>"},{"location":"mentions/","title":"Controlling Mentions","text":"<p>The client exposes settings to control how mentions behave in outgoing messages.</p>"},{"location":"mentions/#default-allowed-mentions","title":"Default Allowed Mentions","text":"<p>Use the <code>allowed_mentions</code> parameter of :class:<code>disagreement.Client</code> to set a default for all messages:</p> <pre><code>from disagreement import AllowedMentions, Client\nclient = Client(\n    token=\"YOUR_TOKEN\",\n    allowed_mentions=AllowedMentions.none().to_dict(),\n)\n</code></pre> <p>When <code>Client.send_message</code> or convenience methods like <code>Message.reply</code> and <code>CommandContext.reply</code> are called without an explicit <code>allowed_mentions</code> argument this value will be used.</p> <p><code>AllowedMentions</code> also provides the convenience methods <code>AllowedMentions.none()</code> and <code>AllowedMentions.all()</code> to quickly create common configurations.</p>"},{"location":"mentions/#next-steps","title":"Next Steps","text":"<ul> <li>Commands</li> <li>HTTP Client Options</li> </ul>"},{"location":"message_history/","title":"Message History","text":"<p><code>TextChannel.history</code> provides an async iterator over a channel's past messages. The iterator is powered by <code>utils.message_pager</code> which handles pagination for you.</p> <pre><code>channel = await client.fetch_channel(123456789012345678)\nasync for message in channel.history(limit=200):\n    print(message.content)\n</code></pre> <p>Each returned <code>Message</code> has a <code>jump_url</code> property that links directly to the message in the Discord client.</p> <p>Pass <code>before</code> or <code>after</code> to control the range of messages returned. The paginator fetches messages in batches of up to 100 until the limit is reached or Discord returns no more messages.</p>"},{"location":"message_history/#next-steps","title":"Next Steps","text":"<ul> <li>Caching</li> <li>Typing Indicator</li> <li>Audit Logs</li> <li>HTTP Client Options</li> </ul>"},{"location":"oauth2/","title":"OAuth2 Setup","text":"<p>This guide explains how to perform a basic OAuth2 flow with <code>disagreement</code>.</p> <ol> <li>Generate the authorization URL:</li> </ol> <pre><code>from disagreement.oauth import build_authorization_url\n\nurl = build_authorization_url(\n    client_id=\"YOUR_CLIENT_ID\",\n    redirect_uri=\"https://your.app/callback\",\n    scope=[\"identify\"],\n)\nprint(url)\n</code></pre> <ol> <li>After the user authorizes your application and you receive a code, exchange it for a token:</li> </ol> <pre><code>import aiohttp\nfrom disagreement.oauth import exchange_code_for_token\n\nasync def get_token(code: str):\n    return await exchange_code_for_token(\n        client_id=\"YOUR_CLIENT_ID\",\n        client_secret=\"YOUR_CLIENT_SECRET\",\n        code=code,\n        redirect_uri=\"https://your.app/callback\",\n    )\n</code></pre> <p><code>exchange_code_for_token</code> returns the JSON payload from Discord which includes <code>access_token</code>, <code>refresh_token</code> and expiry information.</p> <ol> <li>When the access token expires, you can refresh it using the provided refresh token:</li> </ol> <pre><code>from disagreement.oauth import refresh_access_token\n\nasync def refresh(token: str):\n    return await refresh_access_token(\n        refresh_token=token,\n        client_id=\"YOUR_CLIENT_ID\",\n        client_secret=\"YOUR_CLIENT_SECRET\",\n    )\n</code></pre>"},{"location":"permissions/","title":"Permission Helpers","text":"<p>The <code>disagreement.permissions</code> module defines an :class:<code>~enum.IntFlag</code> <code>Permissions</code> enumeration along with helper functions for working with the Discord permission bitmask.</p>"},{"location":"permissions/#permissions-enum","title":"Permissions Enum","text":"<p>Each attribute of <code>Permissions</code> represents a single permission bit. The value is a power of two so multiple permissions can be combined using bitwise OR.</p> <pre><code>from disagreement import Permissions\n\nvalue = Permissions.SEND_MESSAGES | Permissions.MANAGE_MESSAGES\n</code></pre>"},{"location":"permissions/#helper-functions","title":"Helper Functions","text":""},{"location":"permissions/#permissions_value","title":"<code>permissions_value</code>","text":"<pre><code>permissions_value(*perms) -&gt; int\n</code></pre> <p>Return an integer bitmask from one or more <code>Permissions</code> values. Nested iterables are flattened automatically.</p>"},{"location":"permissions/#has_permissions","title":"<code>has_permissions</code>","text":"<pre><code>has_permissions(current, *perms) -&gt; bool\n</code></pre> <p>Return <code>True</code> if <code>current</code> (an <code>int</code> or <code>Permissions</code>) contains all of the provided permissions.</p>"},{"location":"permissions/#missing_permissions","title":"<code>missing_permissions</code>","text":"<pre><code>missing_permissions(current, *perms) -&gt; List[Permissions]\n</code></pre> <p>Return a list of permissions that <code>current</code> does not contain.</p>"},{"location":"permissions/#example","title":"Example","text":"<pre><code>from disagreement.permissions import (\n    has_permissions,\n    missing_permissions,\n)\nfrom disagreement import Permissions\n\ncurrent = Permissions.SEND_MESSAGES | Permissions.MANAGE_MESSAGES\n\nif has_permissions(current, Permissions.SEND_MESSAGES):\n    print(\"Can send messages\")\n\nprint(missing_permissions(current, Permissions.ADMINISTRATOR))\n</code></pre>"},{"location":"presence/","title":"Updating Presence","text":"<p>The <code>Client.change_presence</code> method allows you to update the bot's status and displayed activity. Pass an :class:<code>~disagreement.models.Activity</code> (such as :class:<code>~disagreement.models.Game</code> or :class:<code>~disagreement.models.Streaming</code>) to describe what your bot is doing.</p>"},{"location":"presence/#status-strings","title":"Status Strings","text":"<ul> <li><code>online</code> \u2013 show the bot as online</li> <li><code>idle</code> \u2013 mark the bot as away</li> <li><code>dnd</code> \u2013 do not disturb</li> <li><code>invisible</code> \u2013 appear offline</li> </ul>"},{"location":"presence/#activity-types","title":"Activity Types","text":"<p>An activity dictionary must include a <code>name</code> and a <code>type</code> field. The type value corresponds to Discord's activity types:</p> Type Meaning <code>0</code> Playing <code>1</code> Streaming <code>2</code> Listening <code>3</code> Watching <code>4</code> Custom <code>5</code> Competing <p>Example using the provided activity classes:</p> <pre><code>from disagreement import Game\n\nawait client.change_presence(status=\"idle\", activity=Game(\"with Discord\"))\n</code></pre> <p>You can also specify a streaming URL:</p> <pre><code>from disagreement import Streaming\n\nawait client.change_presence(status=\"online\", activity=Streaming(\"My Stream\", \"https://twitch.tv/someone\"))\n</code></pre>"},{"location":"rate_limiter/","title":"Rate Limiter","text":"<p>The HTTP client uses an asynchronous <code>RateLimiter</code> to respect Discord's per-route and global rate limits. Each request acquires a bucket associated with the route. The limiter delays requests when the bucket is exhausted and handles global rate limits automatically.</p> <pre><code>from disagreement.rate_limiter import RateLimiter\n\nrl = RateLimiter()\nbucket = await rl.acquire(\"GET:/channels/1\")\n# perform request\nrl.release(\"GET:/channels/1\", response_headers)\n</code></pre> <p><code>handle_rate_limit(route, retry_after, is_global)</code> can be used when the API returns a rate limit response.</p>"},{"location":"reactions/","title":"Handling Reactions","text":"<p><code>disagreement</code> provides several ways to add, remove, and listen for message reactions.</p>"},{"location":"reactions/#adding-removing-reactions","title":"Adding &amp; Removing Reactions","text":"<p>The easiest way to add a reaction is to use the helper method on a <code>Message</code> object. This is often done within a command context.</p> <pre><code># Inside a command function:\n# ctx is a commands.CommandContext object\nawait ctx.message.add_reaction(\"\ud83d\udc4d\")\n</code></pre> <p>You can also remove your own reactions.</p> <pre><code>await ctx.message.remove_reaction(\"\ud83d\udc4d\", client.user)\n</code></pre>"},{"location":"reactions/#low-level-control","title":"Low-Level Control","text":"<p>For more direct control, you can use methods on the <code>Client</code> or <code>HTTPClient</code> if you have the channel and message IDs.</p> <pre><code># Using the client helper\nawait client.create_reaction(channel_id, message_id, \"\ud83d\udc4d\")\n\n# Using the raw HTTP method\nawait client._http.create_reaction(channel_id, message_id, \"\ud83d\udc4d\")\n</code></pre> <p>Similarly, you can delete reactions and get a list of users who reacted.</p> <pre><code># Delete a specific user's reaction\nawait client.delete_reaction(channel_id, message_id, \"\ud83d\udc4d\", user_id)\n\n# Get users who reacted with an emoji\nusers = await client.get_reactions(channel_id, message_id, \"\ud83d\udc4d\")\n</code></pre>"},{"location":"reactions/#reaction-events","title":"Reaction Events","text":"<p>Your bot can listen for reaction events by using the <code>@client.on_event</code> decorator. The two main events are <code>MESSAGE_REACTION_ADD</code> and <code>MESSAGE_REACTION_REMOVE</code>.</p> <p>The event handlers for these events receive both a <code>Reaction</code> object and the <code>User</code> or <code>Member</code> who triggered the event.</p> <p>```python import disagreement from disagreement import Reaction, User, Member</p> <p>@client.on_event(\"MESSAGE_REACTION_ADD\") async def on_reaction_add(reaction: Reaction, user: User | Member):     # Ignore reactions from the bot itself     if client.user and user.id == client.user.id:         return     print(f\"{user.username} reacted to message {reaction.message_id} with {reaction.emoji}\")</p> <p>@client.on_event(\"MESSAGE_REACTION_REMOVE\") async def on_reaction_remove(reaction: Reaction, user: User | Member):     print(f\"{user.username} removed their {reaction.emoji} reaction from message {reaction.message_id}\")</p>"},{"location":"scheduled_events/","title":"Guild Scheduled Events","text":"<p>The <code>Client</code> provides helpers to manage guild scheduled events.</p> <pre><code>from disagreement import Client\n\nclient = Client(token=\"TOKEN\")\n\npayload = {\n    \"name\": \"Movie Night\",\n    \"scheduled_start_time\": \"2024-05-01T20:00:00Z\",\n    \"privacy_level\": 2,\n    \"entity_type\": 3,\n    \"entity_metadata\": {\"location\": \"https://discord.gg/example\"},\n}\n\nevent = await client.create_scheduled_event(123456789012345678, payload)\nprint(event.id, event.name)\n</code></pre>"},{"location":"scheduled_events/#next-steps","title":"Next Steps","text":"<ul> <li>Commands</li> <li>Caching</li> <li>Voice Features</li> </ul>"},{"location":"sharding/","title":"Sharding","text":"<p><code>disagreement</code> supports splitting your gateway connection across multiple shards. Use <code>Client</code> with the <code>shard_count</code> parameter when you want to control the count manually.</p> <p><code>AutoShardedClient</code> asks Discord for the recommended number of shards at runtime and configures the <code>ShardManager</code> automatically.</p> <pre><code>import asyncio\nimport disagreement\n\nbot = disagreement.AutoShardedClient(token=\"YOUR_TOKEN\")\n\nasync def main():\n    await bot.run()\n\nasyncio.run(main())\n</code></pre>"},{"location":"slash_commands/","title":"Using Slash Commands","text":"<p>The library provides a slash command framework to define commands with decorators and register them with Discord.</p> <pre><code>from disagreement import AppCommandGroup\n\nbot_commands = AppCommandGroup(\"bot\", \"Bot commands\")\n\n@bot_commands.command(name=\"ping\")\nasync def ping(ctx):\n    await ctx.respond(\"Pong!\")\n</code></pre> <p>Use <code>AppCommandGroup</code> to group related commands. See the components guide for building interactive responses.</p>"},{"location":"slash_commands/#next-steps","title":"Next Steps","text":"<ul> <li>Components</li> <li>Caching</li> <li>Voice Features</li> <li>HTTP Client Options</li> </ul>"},{"location":"slash_commands/#command-persistence","title":"Command Persistence","text":"<p><code>AppCommandHandler.sync_commands</code> can persist registered command IDs in <code>.disagreement_commands.json</code>. When enabled, subsequent syncs compare the stored IDs to the commands defined in code and only create, edit or delete commands when changes are detected.</p> <p>Call <code>AppCommandHandler.clear_stored_registrations()</code> if you need to wipe the stored IDs or migrate them elsewhere with <code>AppCommandHandler.migrate_stored_registrations()</code>.</p>"},{"location":"task_loop/","title":"Task Loops","text":"<p>The tasks extension allows you to run functions periodically. Decorate an async function with <code>@loop</code> and start it using <code>.start()</code>.</p> <pre><code>from disagreement import loop\n\n@loop(minutes=1.0)\nasync def announce():\n    print(\"Hello from a loop\")\n\nannounce.start()\n</code></pre> <p>Stop the loop with <code>.stop()</code> when you no longer need it.</p> <p>You can provide the interval in seconds, minutes, hours or as a <code>datetime.timedelta</code>:</p> <pre><code>import datetime\n\n@loop(delta=datetime.timedelta(seconds=30))\nasync def ping():\n    ...\n</code></pre> <p>Handle exceptions raised by the looped coroutine using <code>on_error</code>:</p> <pre><code>async def log_error(exc: Exception) -&gt; None:\n    print(\"Loop failed:\", exc)\n\n@loop(seconds=5.0, on_error=log_error)\nasync def worker():\n    ...\n</code></pre> <p>Run setup and teardown code using <code>before_loop</code> and <code>after_loop</code>:</p> <pre><code>@loop(seconds=5.0)\nasync def worker():\n    ...\n\n@worker.before_loop\nasync def before_worker():\n    print(\"starting\")\n\n@worker.after_loop\nasync def after_worker():\n    print(\"stopped\")\n</code></pre> <p>You can also schedule a task at a specific time of day:</p> <pre><code>from datetime import datetime, timedelta\n\ntime_to_run = (datetime.now() + timedelta(seconds=5)).time()\n\n@loop(time_of_day=time_to_run)\nasync def daily_task():\n    ...\n</code></pre>"},{"location":"threads/","title":"Threads","text":"<p><code>Message.create_thread</code> and <code>TextChannel.create_thread</code> let you start new threads. Use :class:<code>AutoArchiveDuration</code> to control when a thread is automatically archived.</p> <pre><code>from disagreement import AutoArchiveDuration\n\nawait message.create_thread(\n    \"discussion\",\n    auto_archive_duration=AutoArchiveDuration.DAY,\n)\n</code></pre>"},{"location":"threads/#next-steps","title":"Next Steps","text":"<ul> <li>Message History</li> <li>Caching</li> </ul>"},{"location":"typing_indicator/","title":"Typing Indicator","text":"<p>The library exposes an async context manager to send the typing indicator for a channel.</p> <pre><code>import asyncio\nfrom disagreement import Client\n\nclient = Client(token=\"YOUR_TOKEN\")\n\nasync def indicate(channel_id: str):\n    async with client.typing(channel_id):\n        await long_running_task()\n</code></pre> <p>This uses the underlying HTTP endpoint <code>/channels/{channel_id}/typing</code>.</p>"},{"location":"using_components/","title":"Using Message Components","text":"<p>This guide explains how to work with the <code>disagreement</code> message component models. These examples are up to date with the current code base.</p>"},{"location":"using_components/#enabling-the-new-component-system","title":"Enabling the New Component System","text":"<p>Messages that use the component system must include the flag <code>IS_COMPONENTS_V2</code> (value <code>1 &lt;&lt; 15</code>). Once this flag is set on a message it cannot be removed.</p>"},{"location":"using_components/#component-categories","title":"Component Categories","text":"<p>The library exposes three broad categories of components:</p> <ul> <li>Layout Components \u2013 organize the placement of other components.</li> <li>Content Components \u2013 display static text or media.</li> <li>Interactive Components \u2013 allow the user to interact with your message.</li> </ul>"},{"location":"using_components/#action-row","title":"Action Row","text":"<p><code>ActionRow</code> is a layout container. It may hold up to five buttons or a single select menu.</p> <pre><code>from disagreement import ActionRow, Button, ButtonStyle\n\nrow = ActionRow(components=[\n    Button(style=ButtonStyle.PRIMARY, label=\"Click\", custom_id=\"btn\")\n])\n</code></pre>"},{"location":"using_components/#button","title":"Button","text":"<p>Buttons provide a clickable UI element.</p> <pre><code>from disagreement import Button, ButtonStyle\n\nbutton = Button(\n    style=ButtonStyle.SUCCESS,\n    label=\"Confirm\",\n    custom_id=\"confirm_button\",\n)\n</code></pre>"},{"location":"using_components/#select-menus","title":"Select Menus","text":"<p><code>SelectMenu</code> lets the user choose one or more options. The <code>type</code> parameter controls the menu variety (<code>STRING_SELECT</code>, <code>USER_SELECT</code>, <code>ROLE_SELECT</code>, <code>MENTIONABLE_SELECT</code>, <code>CHANNEL_SELECT</code>).</p> <pre><code>from disagreement import SelectMenu, SelectOption, ComponentType, ChannelType\n\nmenu = SelectMenu(\n    custom_id=\"example\",\n    options=[\n        SelectOption(label=\"Option 1\", value=\"1\"),\n        SelectOption(label=\"Option 2\", value=\"2\"),\n    ],\n    placeholder=\"Choose an option\",\n    min_values=1,\n    max_values=1,\n    type=ComponentType.STRING_SELECT,\n)\n</code></pre> <p>For channel selects you may pass <code>channel_types</code> with a list of allowed <code>ChannelType</code> values.</p>"},{"location":"using_components/#section","title":"Section","text":"<p><code>Section</code> groups one or more <code>TextDisplay</code> components and can include an accessory <code>Button</code> or <code>Thumbnail</code>.</p> <pre><code>from disagreement import Section, TextDisplay, Thumbnail, UnfurledMediaItem\n\nsection = Section(\n    components=[\n        TextDisplay(content=\"## Section Title\"),\n        TextDisplay(content=\"Sections can hold multiple text displays.\"),\n    ],\n    accessory=Thumbnail(media=UnfurledMediaItem(url=\"https://example.com/img.png\")),\n)\n</code></pre>"},{"location":"using_components/#text-display","title":"Text Display","text":"<p><code>TextDisplay</code> simply renders markdown text.</p> <pre><code>from disagreement import TextDisplay\n\ntext_display = TextDisplay(content=\"**Bold text**\")\n</code></pre>"},{"location":"using_components/#thumbnail","title":"Thumbnail","text":"<p><code>Thumbnail</code> shows a small image. Set <code>spoiler=True</code> to hide the image until clicked.</p> <pre><code>from disagreement import Thumbnail, UnfurledMediaItem\n\nthumb = Thumbnail(\n    media=UnfurledMediaItem(url=\"https://example.com/image.png\"),\n    description=\"A picture\",\n    spoiler=False,\n)\n</code></pre>"},{"location":"using_components/#media-gallery","title":"Media Gallery","text":"<p><code>MediaGallery</code> holds multiple <code>MediaGalleryItem</code> objects.</p> <pre><code>from disagreement import MediaGallery, MediaGalleryItem, UnfurledMediaItem\n\ngallery = MediaGallery(\n    items=[\n        MediaGalleryItem(media=UnfurledMediaItem(url=\"https://example.com/1.png\")),\n        MediaGalleryItem(media=UnfurledMediaItem(url=\"https://example.com/2.png\")),\n    ]\n)\n</code></pre>"},{"location":"using_components/#file","title":"File","text":"<p><code>File</code> displays an uploaded file. Use <code>spoiler=True</code> to mark it as a spoiler.</p> <pre><code>from disagreement import File, UnfurledMediaItem\n\nfile_component = File(\n    file=UnfurledMediaItem(url=\"attachment://file.zip\"),\n    spoiler=False,\n)\n</code></pre>"},{"location":"using_components/#separator","title":"Separator","text":"<p><code>Separator</code> adds vertical spacing or an optional divider line between components.</p> <pre><code>from disagreement import Separator\n\nseparator = Separator(divider=True, spacing=2)\n</code></pre>"},{"location":"using_components/#container","title":"Container","text":"<p><code>Container</code> visually groups a set of components and can apply an accent colour or spoiler.</p> <pre><code>from disagreement import Container, TextDisplay\n\ncontainer = Container(\n    components=[TextDisplay(content=\"Inside a container\")],\n    accent_color=\"#FF0000\",  # int or Color() also work\n    spoiler=False,\n)\n</code></pre> <p>A container can itself contain layout and content components, letting you build complex messages.</p>"},{"location":"using_components/#next-steps","title":"Next Steps","text":"<ul> <li>Slash Commands</li> <li>Caching</li> <li>Voice Features</li> <li>HTTP Client Options</li> </ul>"},{"location":"voice_client/","title":"VoiceClient","text":"<p><code>VoiceClient</code> provides a minimal interface to Discord's voice gateway. It handles the WebSocket handshake and lets you stream audio over UDP.</p>"},{"location":"voice_client/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nimport os\nimport disagreement\n\nasync def main():\n    async with disagreement.VoiceClient(\n        os.environ[\"DISCORD_VOICE_ENDPOINT\"],\n        os.environ[\"DISCORD_SESSION_ID\"],\n        os.environ[\"DISCORD_VOICE_TOKEN\"],\n        int(os.environ[\"DISCORD_GUILD_ID\"]),\n        int(os.environ[\"DISCORD_USER_ID\"]),\n    ) as vc:\n        await vc.send_audio_frame(b\"...\")\n\nasyncio.run(main())\n</code></pre> <p>After connecting you can send raw Opus frames:</p> <pre><code>await vc.send_audio_frame(opus_bytes)\n</code></pre> <p>Or stream audio using an :class:<code>AudioSource</code>:</p> <pre><code>from disagreement import FFmpegAudioSource\n\nsource = FFmpegAudioSource(\"welcome.mp3\")\nawait vc.play(source)\n</code></pre> <p>You can switch sources while connected:</p> <pre><code>await vc.play(FFmpegAudioSource(\"other.mp3\"))\n</code></pre> <p>The connection will be closed automatically when leaving the <code>async with</code> block.</p>"},{"location":"voice_client/#fetching-available-voice-regions","title":"Fetching Available Voice Regions","text":"<p>Use :meth:<code>Client.fetch_voice_regions</code> to list the voice regions that Discord currently offers. The method returns a list of :class:<code>VoiceRegion</code> values.</p> <pre><code>regions = await client.fetch_voice_regions()\nfor region in regions:\n    print(region.value)\n</code></pre>"},{"location":"voice_features/","title":"Voice Features","text":"<p>Disagreement includes experimental support for connecting to voice channels. You can join a voice channel and play audio using an :class:<code>AudioSource</code>.</p> <pre><code>voice = await client.join_voice(guild_id, channel_id)\nawait voice.play_file(\"welcome.mp3\")\nawait voice.play_file(\"another.mp3\")  # switch sources while connected\nawait voice.close()\n</code></pre> <p>Voice support is optional and may require additional system dependencies such as FFmpeg.</p>"},{"location":"voice_features/#next-steps","title":"Next Steps","text":"<ul> <li>Components</li> <li>Slash Commands</li> <li>Caching</li> <li>HTTP Client Options</li> </ul>"},{"location":"webhooks/","title":"Working with Webhooks","text":"<p>The <code>HTTPClient</code> includes helper methods for creating, editing and deleting Discord webhooks.</p>"},{"location":"webhooks/#create-a-webhook","title":"Create a webhook","text":"<pre><code>from disagreement import HTTPClient\n\nhttp = HTTPClient(token=\"TOKEN\")\npayload = {\"name\": \"My Webhook\"}\nwebhook = await http.create_webhook(\"123\", payload)\n</code></pre>"},{"location":"webhooks/#edit-a-webhook","title":"Edit a webhook","text":"<pre><code>await http.edit_webhook(\"456\", {\"name\": \"Renamed\"})\n</code></pre>"},{"location":"webhooks/#delete-a-webhook","title":"Delete a webhook","text":"<pre><code>await http.delete_webhook(\"456\")\n</code></pre> <p>The methods now return a <code>Webhook</code> object directly:</p> <pre><code>from disagreement import Webhook\n\nprint(webhook.id, webhook.name)\n</code></pre>"},{"location":"webhooks/#create-a-webhook-from-a-url","title":"Create a Webhook from a URL","text":"<p>You can construct a <code>Webhook</code> object from an existing webhook URL without any API calls:</p> <pre><code>from disagreement import Webhook\n\nwebhook = Webhook.from_url(\"https://discord.com/api/webhooks/123/token\")\nprint(webhook.id, webhook.token)\n</code></pre>"},{"location":"webhooks/#send-a-message-through-a-webhook","title":"Send a message through a Webhook","text":"<p>Once you have a <code>Webhook</code> instance bound to a :class:<code>Client</code>, you can send messages using it:</p> <pre><code>webhook = await client.create_webhook(\"123\", {\"name\": \"Bot Webhook\"})\nawait webhook.send(content=\"Hello from my webhook!\", username=\"Bot\")\n</code></pre>"}]}